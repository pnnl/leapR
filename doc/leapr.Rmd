---
title: "leapr"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{leapr}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```



```{r setup}
library(leapr)

```


This is intended to be a short introduction to the `leapr` package.

# Definitions 
*Dataset* - in this case I'm generally talking about a matrix of components (rows) measured in the same system under multiple different conditions (columns)

*Component* - the things being measured, genes, proteins, methylation site, phosphosite, etc. For functional (currently) the component must be associated with a gene name. That is, there's not currently a way to calculate pathway enrichment using lipids.

*Pathway* - here I'm using this to mean 'a group of components that works together to accomplish something or are related to each other in some other way'. This includes classic signaling and metabolic pathways, but also molecular function and localization categories and other groups of related components, like genome location, conservation, etc.

*Condition* - a sample where the treatment, environmental conditions, patient, time point or some combination of those is varied. 

The overall idea for functional enrichment is to determine which pathways
are statistically over-represented in one group versus another, display statistically differential
abundance from one group to another, or are statistically differentially distributed in a ranked 
list based on the abundance of one sample. Each of these purposes has a different underlying statistical test (or families of tests) and the results of each can be interpreted in somewhat different ways.

In the following sections I have tried to step through each application, list the possible uses for the application, and how it should be interpreted- using an example dataset (and constructing example data/lists/etc from the example data). There are a number of caveats that I also attempt to capture here.

# Important points for consideration

### 1. Data normalization
One important point is to use data that's been normalized in a particular way to do these analyses. I normalize as a Z score *by row* (gene/protein/etc.). So, for each row, calculate the mean and standard deviation across all the conditions (columns) and then express as a Z score. 

Here's why. All high-throughput technologies (microarray, RNAseq, MS-assisted proteomics, metabolomics, lipidomics, etc.) suffer from the same limitation. The detectability of each molecule being detected (protein, RNA, etc.) is different and, in general, it's impossible to accurately determine *how detectable* each one is. The functional enrichment process lumps together measurements from different components (proteins, genes, etc.) to summarize a pathway. If the component measurements aren't directly comparable (they aren't) then this can and will introduce significant systematic errors and won't produce the results you're looking for. 

This caveat actually limits the applicability of functional enrichment for data which have limited number of samples (two condition comparisons for example). In those cases using an approach like Fisher's exact is a reasonable one. For example identifying those components that are differentially expressed between conditions and then assessing enrichment of the differentially expressed components relative to all other conditions.

### 2. Background
The background of comparison for functional enrichment is always important, but really only impacts the Fisher's exact tests in my applications below. The background is the answer to "my functional group of interest is statistically enriched relative to what?" For Fisher's exact tests this is really important. [tbc]

### 3. Multiple hypothesis correction
When testing the statistical significance of differences in a lot of pathways it's necessary to correct for multiple hypotheses. This essentially accounts for the possibility you might see SOMETHING significant by chance if you just test enough things- so it moves p values in a less significant direction. The more things you test, the greater this move will be. So pathway databases with lots of pathways are affected more by this correction, making it harder to get a significant result (which is a good thing actually).

### 4. Pathway databases
I have included two 'databases' (organized text files) for pathways. The first is taken from the NCI's Pathway Interaction Database (PID) and covers signaling pathways in human. The second is taken from the MSIGDB (the same database used by GSEA) that has lots of different pathways gathered from multiple different sources- some are more useful than others. The MSIGDB is good for giving more options- but runs into multiple hypothesis correction issues (see above). They can be loaded as follows:
```
data(msigdb)
data(ncipid)
```

### 5. Identifiers
The identifiers (gene names, e.g.) for the data input MUST match the identifiers used in the pathway database. For the two human databases that I've included I use the HGNC-approved gene names. Which means your data has to use the same identifiers.

### 6. Example data
I've included a sample data set that is from the CPTAC study of 169 ovarian tumors. For each application I've formatted the data to be an example of the type of analysis and also try to point out other ways you might use the approach (either in examples or as text). This data can be loaded as follows:
```
data(protdata)
```
We also include some groups of patients to compare:
```
data(shortlist)
data(longlist)
```

The data are now loaded and ready to go through some of the examples. 

# Examples


## Example 1: Comparison of one condition/group versus another condition/group.

There are a number of ways to do this. I generally use a simple approach which
assesses the statistical difference in distributions between the abundance values
from all the members of a pathway in all the group members from one group with those
from the other group using a t test. 

### Caveat
This is a 'bag of values' approach and it does not pay attention to the
relationships between values in different groups (i.e. that each group has measurements
for the same component). There are likely issues that arise because of this and
caveats associated with it. However, it works fairly well.

### Description
In this example we are assessing the enrichment of pathways in
a group of short surviving patients versus in a group of long surviving patients.
We can also do a single patient-to-patient comparison or compare a single patient
to a group of patients.

### Interpretation
Better corrected p-values are more enriched. However, you can get good
p-values when the algorithm only considers a limited number of components from a pathway. That is, the pathway may have 30 members and the p-value is coming from values from just 3 members. You can look at the `ingroup_n` column from the result matrix to see this (and screen out if desired).

It is VERY important to also consider the effect size. That is, the difference between the mean of one group and the mean of the other group. If there are large numbers of components in the pathway being compared it is relatively easy to get a significant p value with small effect size. Though this may be a real difference it is often not as interesting as a smaller group with worse p value and greater effect size. You can look at the effect size by comparing the `ingroup_mean` and `outgroup_mean` columns.

```{r abundance, echo=TRUE, warning=FALSE}


# in this example we lump a bunch of patients together (the 'short survivors') and compare
#   them to another group (the 'long survivors')

###using enrichment_wrapper function
protdata.enrichment.svl = enrichment_wrapper(geneset=ncipid, 
                                             enrichment_method='enrichment_in_abundance',
                                             datamatrix=protdata, primary_columns=shortlist,
                                             secondary_columns=longlist)

# I generally output these files and then view them in Excel afterward
write.table(protdata.enrichment.svl, 
            file="protdata.enrichment.svl.txt",
            sep="\t", quote=F)

knitr::kable(head(protdata.enrichment.svl))
# another application is to compare just one patient against another (this would be the
#     equivalent of comparing one time point to another)
#protdata.enrichment.svl.ovo = enrichment_in_abundance(ncipid, protdata, abundance_column=shortlist[1], sample_comparison=longlist[1])

###using enrichment_wrapper function
protdata.enrichment.svl.ovo = enrichment_wrapper(geneset=ncipid,
                                                 enrichment_method='enrichment_in_abundance',
                                                 datamatrix=protdata, 
                                                 primary_columns=shortlist[1],
                                                 secondary_columns=longlist[1])
knitr::kable(head(protdata.enrichment.svl.ovo))
```

## Example 2: Fisher's exact test
For this test I use Fisher's exact which is a simple comparison of the overlap of
two sets (think of it like a statistical Venn diagram with two groups). It's also 
referred to as a hypergeometric test. 

### Caveats
*Caveat 1*. Fisher's exact does not consider abundance values but only lists of components. Generally
this requires some separation of a group of interest using differential expression, module membership (from a network for example), or some other method.

*Caveat 2*. The choice of background for comparison can make a big difference on outcome. For example, in a proteomics experiment where you're looking at enrichment in a group of highly differentially expressed proteins, you could choose to use all possible proteins as a background, or you could use just those proteins that were observed by proteomics (generally a much more limited set). The second option is generally the best since the first options will result in (partly to mostly) functions that are enriched in proteins that are seen in proteomics. That is, the most abundant proteins, which is generally not the desired outcome.

### Description
In the example below I construct a genelist of interest using a simple abundance threshold on the data
then use a background of all the genes in the example dataset (which is a limited number). I then do a simple hierarchical clustering on the data, extract modules, and step through each module to calculate enrichment for them, outputting the results into a separate text file.

### Interpretation
As with the t test comparison above it is important to look at the number of pathway members included in the comparison (look at the in_path column). There is no 'effect size' problem with Fisher's exact since it's just a set comparison, but it's important to note that significant p values can arise from a pathway being *underrepresented* in the genelist, which often times is not the desired result. The foldx column gives a ratio of in versus not in the genelist, values > 1 being enriched and <1 being depleted.

``` {r fishers, echo=TRUE, warning=FALSE}
# for this example we will construct a list of genes from the expression data
#     to emulate what you might be inputting
genelist = rownames(protdata)[which(protdata[,1]>0.5)]
background = rownames(protdata)

#prodata.enrichment.fishers = enrichment_in_groups(ncipid, targets=genelist, background=background)

###using enrichment_wrapper function
prodata.enrichment.fishers = enrichment_wrapper(geneset=ncipid,
                                                enrichment_method="enrichment_by_fishers",
                                                datamatrix=protdata, threshold=.5,
                                                primary_columns="TCGA-13-1484")


# in this example we construct some modules from the hierarchical clustering of the
#     data
protdata_naf = as.matrix(protdata)

# hierarchical clustering is not too happy with lots of missing values
#    so we'll do a zero fill on this to get the modules
protdata_naf[which(is.na(protdata_naf))] = 0

# construct the hierarchical clustering using the 'wardD' method, which
#    seems to give more even sized modules
protdata_hc = hclust(dist(protdata_naf), method="ward.D2")

# arbitrarily we'll chop the clusters into 5 modules
modules = cutree(protdata_hc, k=5)
# modules is a named list of values where each value is a module
#         number and the name is the gene name

# To do enrichment for one module (module 1 in this case) do this
protdata.enrichment.fishers.module_1 = enrichment_in_groups(ncipid, targets=names(modules[which(modules==1)]),
                                                            background=names(modules))

# To do enrichment for all modules and dump the results into text files
# do this

all.results<-do.call(rbind,lapply(c(1:5),function(i) {
    res=enrichment_in_groups(ncipid, targets=names(modules[which(modules==i)]),
                                 background=names(modules))   
    res$module=i
    res}))




knitr::kable(head(all.results[order(all.results$pvalue),]))

```

## Example 3. The Kolmogorovâ€“Smirnov test (KS or Vodka Test)
Similar to the popular GSEA, KS tests whether a group of components (the pathway) is distributed in a statistically significant manner in a ranked list of components. That is, if all the members of the pathway are clustered together at the top of the list (highly abundant, e.g.) or at the bottom of the list (low abundance, e.g.) this will return good p values. I should note that GSEA uses a somewhat more sophisticated approach than this and their application has a lot of bells and whistles.

### Description
In the example below I'm simply calculating enrichment for one of the patients in the list (arbitrarily selected). The ranking value is relative protein abundance in this case, but can be any continuous measure or derived value. For example, you could calculate the topology of all proteins in a network and use the topology measure (degree) as the measure. 

### Interpretation
Similar to the other examples be cautious of pathways with good p values that consider a small number of pathway numbers (in_path column). The MeanPath column gives a measure that shows how far above or below the median the mean rank of the pathway is (normalized to -1,1). The Zscore column is a Zscore calculated on the basis of the mean percentage rank of the pathway relative to the mean of the entire list divided by the standard deviation of the pathway rank. The foldx column expresses the mean percentage rank of the pathway relative to the entire list - closer to 0 is higher in the list and closer to 1 is closer to the bottom of the list. Each of these should give consistent results, but will be somewhat different.

``` {r ks, echo=TRUE, warning = FALSE}
# This is how you calculate enrichment in a ranked list (for example from topology)
#prodata.enrichment.ks = enrichment_in_groups(ncipid, background=protdata, method="ks",
#                                             abundance_column=shortlist[1])

###using enrichment_wrapper function
protdata.enrichment.ks = enrichment_wrapper(geneset=ncipid, "enrichment_by_ks", 
                                            datamatrix=protdata, 
                                            primary_columns=shortlist[1])
knitr::kable(head(protdata.enrichment.ks))
```

The 'under development' section.

In this section I'll go through the ideas behind and use of several different kinds of enrichment that I've been working on. Consider this section to be under development and so use at your risk.

## Example 4. Enrichment in correlation
The idea here is to use the correlation of pathway members to each other versus to non-pathway members as a way to assess functional enrichment. This idea seems sound- pathways that are varying in a correlated way across a bunch of conditions (say time points or patients) may be more active and more important than others. However, more testing and validation is needed to show that this is the case.

### Interpretation
The `ingroup_mean` gives the mean correlation of the pathway members to each other and outgroup_mean gives the correlation of the pathway members to non-pathway members. Background_mean gives the mean correlation of all non-pathway members. The `pvalue` and `BH_pvalue` are for the pathway members to each other versus those pathway members to non-pathway components. The `pvalue_background` and `BH_pvalue_background` are for the pathway member correlation relative to non-pathway member correlation (which is similar but slightly different than the other p-values).

``` {r correlation, echo=TRUE, warning=FALSE}


###using enrichment_wrapper function
protdata.enrichment.correlation = enrichment_wrapper(geneset=ncipid, 
                                                     enrichment_method = "correlation_enrichment",
                                                     datamatrix=protdata)

knitr::kable(head(protdata.enrichment.correlation))
protdata.enrichment.correlation.short = enrichment_wrapper(geneset=ncipid, 
                                                           enrichment_method = "correlation_enrichment", 
                                                           datamatrix=protdata[,shortlist])
knitr::kable(head(protdata.enrichment.correlation.short))

protdata.enrichment.correlation.long = enrichment_wrapper(geneset=ncipid, 
                                                          enrichment_method = "correlation_enrichment",
                                                          datamatrix=protdata[,longlist])
knitr::kable(head(protdata.enrichment.correlation.long))
```
